# Miner Configuration
MINER_IP = "192.168.178.180"
API_ENDPOINT = f"http://{MINER_IP}/api/v1"

def get_jwt_token():
    """Obtains a new JWT token from the miner."""
    endpoint = f"{API_ENDPOINT}/unlock"
    payload = {"pw": "admin"}  # Miner password
    try:
        response = requests.post(endpoint, json=payload)
        response.raise_for_status()
        return response.json()['token']
    except requests.exceptions.RequestException as e:
        print(f"Error while obtaining the token: {e}")
        return None

async def read_temperature():
    """Reads the temperature from the DS1820 sensor."""
    sensor = W1ThermSensor()
    try:
        temp = sensor.get_temperature()
        return round(temp, 2)  # Rounds to two decimal places
    except Exception as e:
        print(f"Error while reading the temperature: {e}")
        return None

async def execute_miner_action(endpoint, action_name):
    """Performs an action on the miner, obtaining a new token each time."""
    token = get_jwt_token()
    if token is None:
        print(f"Unable to obtain a valid JWT token for {action_name}.")
        return

    headers = {"Authorization": f"Bearer {token}"}
    try:
        response = requests.post(endpoint, headers=headers)
        response.raise_for_status()
        print(f"Action {action_name} executed successfully.")
    except requests.exceptions.RequestException as e:
        print(f"Error during action {action_name}: {e}")
        if 'response' in locals() and hasattr(response, 'status_code'):
            print(f"Response status code: {response.status_code}")
            if response.status_code == 401:
                print("Token might be expired or invalid.")

async def thermal_control(temp, target_temp):
    if temp is None:
        return

    status_endpoint = f"{API_ENDPOINT}/status"
    token = get_jwt_token()
    if token is None:
        print("Unable to obtain a valid JWT token to check miner status.")
        return

    headers = {"Authorization": f"Bearer {token}"}
    try:
        status_response = requests.get(status_endpoint, headers=headers)
        status_response.raise_for_status()
        miner_status = status_response.json()
        current_status = miner_status.get('miner_state', 'unknown')

        print(f"Miner Status: {current_status}")

        if temp <= target_temp - 2 and current_status not in ['mining', 'starting']:
            await execute_miner_action(f"{API_ENDPOINT}/mining/start", "start mining")
            print("Temperature too low: Mining Started")
        elif temp >= target_temp and current_status == 'mining':
            await execute_miner_action(f"{API_ENDPOINT}/mining/stop", "stop mining")
            print("Temperature is ok: Mining Stopped")

    except requests.exceptions.RequestException as e:
        print(f"Mining control error: {e}")

async def main():
    target_temp = float(input("Target temperature: "))

    while True:
        temp = await read_temperature()
        if temp is not None:
            print(f"T: {temp:.2f}Â°C")
            await thermal_control(temp, target_temp)
        else:
            print("Impossible to read temperature.")
        await asyncio.sleep(10)  # Checks every 10 seconds for more frequent updates

if __name__ == "__main__":
    asyncio.run(main())